import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as t,o as l}from"./app-CYsXIaiR.js";const n={};function e(h,i){return l(),a("div",null,i[0]||(i[0]=[t(`<blockquote><p>第31期 R语言正则表达式语法详解及使用场景</p><p>本期主要介绍R语言中的正则表达式的相关用法及使用</p><p>正则表达式在日常数据处理，文本处理，文本分析，爬虫等使用极多</p><p>R语言正则语法与python存在区别。本期基于R语言的正则化进行讲解</p></blockquote><h2 id="什么是正则表达式" tabindex="-1"><a class="header-anchor" href="#什么是正则表达式"><span>什么是正则表达式</span></a></h2><h3 id="正则表达式的概念" tabindex="-1"><a class="header-anchor" href="#正则表达式的概念"><span>正则表达式的概念</span></a></h3><p>正则表达式，是根据字符串规律按一定法则，简洁表达一组字符串的表达式。 正则表达式通常就是从貌似无规律的字符串中发现规律性，进而概括性地表达 它们所共有的规律或模式，以方便地操作处理它们，这是真正的化繁为简，以简驭繁的典范。</p><h3 id="正则表达式的使用场景" tabindex="-1"><a class="header-anchor" href="#正则表达式的使用场景"><span>正则表达式的使用场景</span></a></h3><ul><li>检查文本是否含有指定的特政词</li><li>找出文本中匹配特征词的位置</li><li>从文本中提取信息</li><li>修改文本</li><li>正则表达式包括 <ul><li>只能匹配自身的<strong>普通字符</strong>（如英文字母、数字、标点等）</li><li>被转义了的特殊字符（称为 “<strong>元字符</strong>”），用于构造匹配规则</li><li>比如“我数学考了100分”。用“数学”匹配就是普通字符，用“\\\\d\\\\\\d\\\\\\d”匹配“100”，就是元字符</li></ul></li><li>正则表达式学习建议 <ul><li>先学会最常用的三个正则表达式实例</li><li>遇到具体问题，查阅基本语法表，尝试构造正则表达式，调试得到结果</li></ul></li></ul><h3 id="正则表达式的常用元字符" tabindex="-1"><a class="header-anchor" href="#正则表达式的常用元字符"><span>正则表达式的常用元字符</span></a></h3><figure><img src="https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/JAP2HAMF.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>注意事项 <ul><li>R语言的转义字符是\\\\。其它语言是\\。也就解释R语言读取路径需要用\\\\连接</li><li>默认正则式区别大小写的，可通过<strong>添加参数</strong>来创建忽略大小写的表达式&quot;<strong>ignore_case=FALSE</strong>&quot;</li><li>在多行模式下，<strong>^ 和 $</strong> 就表示行的开始和结束(比较常用的)</li></ul></li></ul><h3 id="正则表达式的特殊元字符" tabindex="-1"><a class="header-anchor" href="#正则表达式的特殊元字符"><span>正则表达式的特殊元字符</span></a></h3><figure><img src="https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/DFQDNCVY.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>其它 <ul><li>\\S+ :匹配不包含空白符的字符串</li><li>\\d，匹配数字</li><li>[a-zA-Z0-9]：匹配数字</li><li>[\\u4e00-\\u9fa5] 匹配汉字</li><li>[^aeiou]: 匹配除 aeiou 之外的任意字符，即匹配辅音字母</li></ul></li></ul><h3 id="posix-字符类" tabindex="-1"><a class="header-anchor" href="#posix-字符类"><span>POSIX 字符类</span></a></h3><figure><img src="https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/JAP2HAMF.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="正则表达式的实例用法" tabindex="-1"><a class="header-anchor" href="#正则表达式的实例用法"><span>正则表达式的实例用法</span></a></h2><h3 id="运算优先级" tabindex="-1"><a class="header-anchor" href="#运算优先级"><span>运算优先级</span></a></h3><p>类似于数学运算的<strong>先后等级</strong></p><p>在正则表达式中圆括号括起来的表达式<strong>最优先</strong>，其次是表示<strong>重复次数</strong>的操作（即 * + { }）；再次是<strong>连接运算</strong>（即几个字符放在一起，如 abc）；最后是或者运算（|）</p><h3 id="懒惰匹配与贪婪匹配" tabindex="-1"><a class="header-anchor" href="#懒惰匹配与贪婪匹配"><span>懒惰匹配与贪婪匹配</span></a></h3><ul><li>基础知识 <ul><li>正则表达式<strong>正常都是贪婪匹配</strong>，即重复直到文本中能匹配的最长范围</li><li><strong>贪婪匹配</strong>：尝试匹配尽可能多的字符。例如，正则表达式 <code>&quot;.*&quot;</code> 会匹配给定字符串中的所有内容。</li><li><strong>懒惰匹配</strong>：则相反，它尝试匹配尽可能少的字符。在R语言中，你可以通过在量词后面添加一个问号 <code>?</code> 来实现懒惰匹配。例如，正则表达式 <code>&quot;.*?&quot;</code> 会匹配尽可能少的字符。</li></ul></li></ul><p>实例说明</p><div class="language-r line-numbers-mode" data-highlighter="shiki" data-ext="r" data-title="r" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 匹配到了最长的内容</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#61AFEF;">str_extract</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;(1st) other (2nd)&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\\\</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">(.+</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\\\</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 如果想要匹配具体的标识符内的内容</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#61AFEF;">str_extract</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;(1st) other (2nd)&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\\\</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">(.+?</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\\\</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/20231211100819.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="零宽匹配" tabindex="-1"><a class="header-anchor" href="#零宽匹配"><span>零宽匹配</span></a></h3><p>零宽匹配是相对于直接匹配的<strong>高级用法</strong>。</p><ul><li>适合想要匹配的内容没有规律性，但该内容位于两个有规律性的标志之间，标志也可以是开始和结束。</li><li>通常想要匹配的内容不包含两边的 “标志”，这就需要用零宽断言。<strong>就是一种引导语法告诉既要匹配到 “标志”，但又不包含 “标志”。</strong></li><li>左边标志的引导语法是 (?&lt;= 标志)，右边标志的引导语法是 (?= 标志)，而真正要匹配的内容放在它们中间。</li></ul><p>实例说明</p><div class="language-r line-numbers-mode" data-highlighter="shiki" data-ext="r" data-title="r" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;20 级预防医学 卓创4 班&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;20 级预防医学 疾控3班&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#想要识别x中的专业名称</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#观察字符串的特征，发现专业夹在&quot;医学 &quot;以及数字（4和3）之间，并且不包含医学和数字，所以使用零宽断言</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#61AFEF;">str_extract</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;(?&lt;=医学 ).*?(?=[0-9])&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/20231211001822.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="重复标识符处理" tabindex="-1"><a class="header-anchor" href="#重复标识符处理"><span>重复标识符处理</span></a></h3><p>如一个字符串对于期望的特征定位符，有多个相同的符号来干扰。如何实现使用自己需要的位置的定位符呢</p><p>参考示例</p><div class="language-r line-numbers-mode" data-highlighter="shiki" data-ext="r" data-title="r" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> paste0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;D:/paper/1.65_kc_ndvi/kc/forest_kc_historical&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">           &quot;_ACCESS-ESM1-5_west_1981_2014.tif&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           # 想要匹配到最后的文件夹名</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           # 观察数据结构，在结构&quot;kc/的右边&quot;,内部结构的组成是forest(非标识符_)，加一个&quot;__&quot;，kc(非标示符),再加一个&quot;__&quot;，historical(非标识符)。根据要求构建正则式</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#61AFEF;">str_extract</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;(?&lt;=kc/)([^_]+_){2}[^_]+&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/20231211002339.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>观察数据结构，在结构&quot;kc/的右边&quot;,内部结构的组成是forest(非标识符_)，加一个&quot;_&quot;，kc(非标示符),再加一个&quot;_&quot;，historical(非标识符)。根据要求构建正则式为&quot;(?&lt;=kc/)([<sup>_]+_){2}[</sup>_]+&quot;</li><li>用法说明 <ul><li><strong>str_extract(x, &quot;(?&lt;=kc/)([<sup>_]+_){2}[</sup>_]+&quot;)</strong>: 这一行使用<code>str_extract()</code>函数从<code>x</code>中提取匹配正则表达式的子串。这个正则表达式&quot;(?&lt;=kc/)([<sup>_]+_){2}[</sup>_]+&quot;的含义如下：</li><li><code>(?&lt;=kc/)</code>: 这是一个正向后视断言（positive lookbehind），它匹配<code>&quot;kc/&quot;</code>之后的内容，但不包括<code>&quot;kc/&quot;</code>本身。</li><li>([^_]+_){2}: 这部分匹配两次不包含下划线<code>_</code>的一个或多个字符序列，后面紧跟一个下划线。每个[^_]+匹配不含下划线的连续字符，<code>_</code>是这些字符后面的下划线。</li><li>[^_]+: 这部分匹配紧随其后的一个不含下划线的字符序列。</li></ul></li><li>&quot;+&quot;号的用法 <ul><li><strong>单个字符：</strong> 如果<code>+</code>号跟在一个字符后面，比如<code>a+</code>，这意味着在目标字符串中匹配一个或多个连续的<code>a</code>字符。例如，在字符串<code>&quot;caaaat&quot;</code>中，<code>a+</code>会匹配连续的<code>aaaa</code>部分。</li><li><strong>字符类：</strong> 当<code>+</code>号用于一个字符类（character class）后面时，如<code>[a-z]+</code>，它会匹配一个或多个连续的在这个字符类中的字符。例如，<code>[a-z]+</code>会匹配字符串<code>&quot;hello world&quot;</code>中的<code>&quot;hello&quot;</code>和<code>&quot;world&quot;</code>。</li><li><strong>子表达式：</strong> 如果<code>+</code>号用于一个子表达式后面，比如<code>(ab)+</code>，它会匹配一个或多个连续的这个子表达式。例如，在字符串<code>&quot;ababcd&quot;</code>中，<code>(ab)+</code>会匹配开头的<code>&quot;abab&quot;</code>部分。</li></ul></li></ul><h3 id="stringr函数实现正则化" tabindex="-1"><a class="header-anchor" href="#stringr函数实现正则化"><span>Stringr函数实现正则化</span></a></h3><ul><li>str_view:调试和查看正则表达式的匹配效果 <ul><li><strong>str_view()</strong>: 此函数用于调试和查看正则表达式的匹配效果。它对于理解和调整你的正则表达式非常有用，尤其是在处理复杂的字符串模式时。<code>str_view()</code>函数会在RStudio的Viewer窗口中展示正则表达式在字符串中的匹配结果，使你可以直观地看到哪些部分被匹配​​。</li></ul></li><li>str_extract()：提取正则表达式匹配到的内容 <ul><li><strong>str_extract()</strong>: 该函数用于提取匹配正则表达式的字符串内容。当你需要从文本中提取特定模式的数据时，这个函数非常有用。例如，如果你有一组字符串，如 <code>&quot;1978-2000&quot;</code> 和 <code>&quot;2011-2020-2099&quot;</code>，并且想要提取出每个字符串中的第一个四位数字，你可以使用正则表达式 <code>&quot;\\\\\\\\d{4}&quot;</code>（表示匹配四位数字），<code>str_extract()</code>会返回第一个匹配的结果，如 <code>&quot;1978&quot;</code> 和 <code>&quot;2011&quot;</code>​​。</li></ul></li><li>str_replace(): 替换正则表达式匹配到的内容 <ul><li><strong>str_replace()</strong>: 这个函数用于替换匹配到的字符串内容。如果你想要修改文本中的特定模式，例如，将所有的短横线<code>&quot;-&quot;</code>替换为斜杠<code>&quot;/&quot;</code>，你可以使用<code>str_replace()</code>。在前面的例子中，如果将 <code>&quot;1978-2000&quot;</code> 和 <code>&quot;2011-2020-2099&quot;</code> 作为输入，并用正则表达式 <code>&quot;-&quot;</code> 和替换字符串 <code>&quot;/&quot;</code>，<code>str_replace()</code>会将第一个匹配到的短横线替换为斜杠，返回 <code>&quot;1978/2000&quot;</code> 和 <code>&quot;2011/2020-2099&quot;</code>​​。</li></ul></li><li><strong>_all 版本的函数</strong>: 对于许多<code>stringr</code>函数，如<code>str_detect</code>、<code>str_extract</code>等，存在一个后缀为_all的版本，比如<code>str_detect_all</code>、<code>str_extract_all</code>。这些_all版本的函数用于在字符串中查找所有匹配的模式，而不仅仅是第一个匹配​​。</li></ul><h2 id="tidyverse下正则表达式的作用" tabindex="-1"><a class="header-anchor" href="#tidyverse下正则表达式的作用"><span>Tidyverse下正则表达式的作用</span></a></h2><h3 id="进行变量值重编码" tabindex="-1"><a class="header-anchor" href="#进行变量值重编码"><span>进行变量值重编码</span></a></h3><p>使用<strong>mutate函数</strong>和<strong>str系列</strong>函数</p><div class="language-r line-numbers-mode" data-highlighter="shiki" data-ext="r" data-title="r" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 示例数据框</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;-</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> data.frame</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  category</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;typeA-123&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;typeB-456&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;typeA-789&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;typeC-101&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">data</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#识别大写字母作为变量,数字作为编号</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">data %&gt;% </span><span style="--shiki-light:#E45649;--shiki-dark:#61AFEF;">mutate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">type</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#61AFEF;">str_extract</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(category,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;[[:upper:]]&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">                number</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#61AFEF;">str_extract</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(category,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\\\</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\\\</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\\\</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">d&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/20231211102940.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="进行变量名的批量修改" tabindex="-1"><a class="header-anchor" href="#进行变量名的批量修改"><span>进行变量名的批量修改</span></a></h3><p>使用<strong>rename_with()和str系列函数</strong>进行变量名的批量修改</p><div class="language-r line-numbers-mode" data-highlighter="shiki" data-ext="r" data-title="r" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 示例数据框，包含不规则的列名</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;-</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> data.frame</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  var_1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  Variable_2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 5</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  another_Var3</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 9</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">12</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">data</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">data %&gt;% </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#61AFEF;">  rename_with</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">~</span><span style="--shiki-light:#E45649;--shiki-dark:#61AFEF;">str_extract</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(.,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;.*(?=_)&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/20231211103718.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>注意事项 <ul><li><code>~</code>是一种简化函数定义的方法，这里它定义了一个匿名函数，其中<code>.</code>代表当前的列名。</li><li>匿名函数在R语言purrr风循环中使用极多，后边会专门进行讲解</li></ul></li></ul><p><strong>推荐书目</strong> 张敬信. <strong>R语言编程  基于tidyverse</strong>. 人民邮电出版社; 2023. Accessed October 16, 2023.</p>`,48)]))}const o=s(n,[["render",e],["__file","第31期 R语言正则表达式语法详解及使用场景.html.vue"]]),d=JSON.parse('{"path":"/%E4%BB%A3%E7%A0%81%E6%95%99%E7%A8%8B/R%E8%AF%AD%E8%A8%80/%E7%AC%AC31%E6%9C%9F%20R%E8%AF%AD%E8%A8%80%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html","title":"第31期 R语言正则表达式语法详解及使用场景","lang":"zh-CN","frontmatter":{"类型":"公众号","公众号内容":["代码-R教程"],"title":"第31期 R语言正则表达式语法详解及使用场景","description":"第31期 R语言正则表达式语法详解及使用场景 本期主要介绍R语言中的正则表达式的相关用法及使用 正则表达式在日常数据处理，文本处理，文本分析，爬虫等使用极多 R语言正则语法与python存在区别。本期基于R语言的正则化进行讲解 什么是正则表达式 正则表达式的概念 正则表达式，是根据字符串规律按一定法则，简洁表达一组字符串的表达式。 正则表达式通常就是从...","head":[["meta",{"property":"og:url","content":"https://wk42.top/%E4%BB%A3%E7%A0%81%E6%95%99%E7%A8%8B/R%E8%AF%AD%E8%A8%80/%E7%AC%AC31%E6%9C%9F%20R%E8%AF%AD%E8%A8%80%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"第31期 R语言正则表达式语法详解及使用场景"}],["meta",{"property":"og:description","content":"第31期 R语言正则表达式语法详解及使用场景 本期主要介绍R语言中的正则表达式的相关用法及使用 正则表达式在日常数据处理，文本处理，文本分析，爬虫等使用极多 R语言正则语法与python存在区别。本期基于R语言的正则化进行讲解 什么是正则表达式 正则表达式的概念 正则表达式，是根据字符串规律按一定法则，简洁表达一组字符串的表达式。 正则表达式通常就是从..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/JAP2HAMF.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-02T10:14:49.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-02T10:14:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第31期 R语言正则表达式语法详解及使用场景\\",\\"image\\":[\\"https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/JAP2HAMF.png\\",\\"https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/DFQDNCVY.png\\",\\"https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/JAP2HAMF.png\\",\\"https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/20231211100819.png\\",\\"https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/20231211001822.png\\",\\"https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/20231211002339.png\\",\\"https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/20231211102940.png\\",\\"https://pic-go-42.oss-cn-guangzhou.aliyuncs.com/img/20231211103718.png\\"],\\"dateModified\\":\\"2024-11-02T10:14:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"wang\\",\\"url\\":\\"https://intro.wk8686.top/\\"}]}"]]},"headers":[{"level":2,"title":"什么是正则表达式","slug":"什么是正则表达式","link":"#什么是正则表达式","children":[{"level":3,"title":"正则表达式的概念","slug":"正则表达式的概念","link":"#正则表达式的概念","children":[]},{"level":3,"title":"正则表达式的使用场景","slug":"正则表达式的使用场景","link":"#正则表达式的使用场景","children":[]},{"level":3,"title":"正则表达式的常用元字符","slug":"正则表达式的常用元字符","link":"#正则表达式的常用元字符","children":[]},{"level":3,"title":"正则表达式的特殊元字符","slug":"正则表达式的特殊元字符","link":"#正则表达式的特殊元字符","children":[]},{"level":3,"title":"POSIX 字符类","slug":"posix-字符类","link":"#posix-字符类","children":[]}]},{"level":2,"title":"正则表达式的实例用法","slug":"正则表达式的实例用法","link":"#正则表达式的实例用法","children":[{"level":3,"title":"运算优先级","slug":"运算优先级","link":"#运算优先级","children":[]},{"level":3,"title":"懒惰匹配与贪婪匹配","slug":"懒惰匹配与贪婪匹配","link":"#懒惰匹配与贪婪匹配","children":[]},{"level":3,"title":"零宽匹配","slug":"零宽匹配","link":"#零宽匹配","children":[]},{"level":3,"title":"重复标识符处理","slug":"重复标识符处理","link":"#重复标识符处理","children":[]},{"level":3,"title":"Stringr函数实现正则化","slug":"stringr函数实现正则化","link":"#stringr函数实现正则化","children":[]}]},{"level":2,"title":"Tidyverse下正则表达式的作用","slug":"tidyverse下正则表达式的作用","link":"#tidyverse下正则表达式的作用","children":[{"level":3,"title":"进行变量值重编码","slug":"进行变量值重编码","link":"#进行变量值重编码","children":[]},{"level":3,"title":"进行变量名的批量修改","slug":"进行变量名的批量修改","link":"#进行变量名的批量修改","children":[]}]}],"git":{"createdTime":1730542489000,"updatedTime":1730542489000,"contributors":[{"name":"WangKang","email":"888666wang4286@gmail.com","commits":1}]},"readingTime":{"minutes":7.95,"words":2385},"filePathRelative":"代码教程/R语言/第31期 R语言正则表达式语法详解及使用场景.md","localizedDate":"2024年11月2日","excerpt":"<blockquote>\\n<p>第31期 R语言正则表达式语法详解及使用场景</p>\\n<p>本期主要介绍R语言中的正则表达式的相关用法及使用</p>\\n<p>正则表达式在日常数据处理，文本处理，文本分析，爬虫等使用极多</p>\\n<p>R语言正则语法与python存在区别。本期基于R语言的正则化进行讲解</p>\\n</blockquote>\\n<h2>什么是正则表达式</h2>\\n<h3>正则表达式的概念</h3>\\n<p>正则表达式，是根据字符串规律按一定法则，简洁表达一组字符串的表达式。 正则表达式通常就是从貌似无规律的字符串中发现规律性，进而概括性地表达 它们所共有的规律或模式，以方便地操作处理它们，这是真正的化繁为简，以简驭繁的典范。</p>","autoDesc":true}');export{o as comp,d as data};
